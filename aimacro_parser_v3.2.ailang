// aimacro_parser_v3.0.ailang
// AIMacro to AILANG transpiler with Python compatibility
// Version 3.0 - Function-style syntax with python_compat library

// Global variables for parameter passing
g_param1 = ""
g_return_value = ""

// Parser state
parser_input = ""
parser_pos = 0
parser_length = 0
output = ""
current_indent = 0
needs_compat = 0  // Flag if python_compat library is needed

// Initialize parser
SubRoutine.InitParser {
    parser_input = g_param1
    parser_pos = 0
    parser_length = StringLength(parser_input)
    output = ""
    current_indent = 0
    needs_compat = 0
}

// Get current character
SubRoutine.GetChar {
    IfCondition LessThan(parser_pos, parser_length) ThenBlock {
        g_return_value = StringCharAt(parser_input, parser_pos)
    } ElseBlock {
        g_return_value = 0  // EOF
    }
}

// Advance position
SubRoutine.NextChar {
    IfCondition LessThan(parser_pos, parser_length) ThenBlock {
        parser_pos = Add(parser_pos, 1)
    }
}

// Skip whitespace (not newlines)
SubRoutine.SkipSpaces {
    RunTask(GetChar)
    ch = g_return_value
    WhileLoop Or(EqualTo(ch, 32), EqualTo(ch, 9)) {
        RunTask(NextChar)
        RunTask(GetChar)
        ch = g_return_value
    }
}

// Read until end of line
SubRoutine.GetLine {
    start = parser_pos
    RunTask(GetChar)
    ch = g_return_value
    WhileLoop And(NotEqual(ch, 10), NotEqual(ch, 0)) {
        RunTask(NextChar)
        RunTask(GetChar)
        ch = g_return_value
    }
    // Use corrected StringSubstring (start, end) after fix
    line = StringSubstring(parser_input, start, parser_pos)
    IfCondition EqualTo(ch, 10) ThenBlock {
        RunTask(NextChar)  // consume newline
    }
    g_return_value = line
}

// Emit with indentation
SubRoutine.EmitIndented {
    line = g_param1
    
    i = 0
    WhileLoop LessThan(i, current_indent) {
        output = StringConcat(output, "    ")
        i = Add(i, 1)
    }
    
    output = StringConcat(output, line)
    output = StringConcat(output, "\n")
}

// Parse function call syntax
SubRoutine.ParseFunctionCall {
    line = g_param1
    func_start = g_param2  // Where function name starts
    
    // Find opening paren
    paren_pos = func_start
    WhileLoop LessThan(paren_pos, StringLength(line)) {
        ch = StringCharAt(line, paren_pos)
        IfCondition EqualTo(ch, 40) ThenBlock {  // (
            // Extract function name (using corrected substring)
            func_name = StringSubstring(line, func_start, paren_pos)
            
            // Find closing paren
            close_pos = Add(paren_pos, 1)
            depth = 1
            WhileLoop And(GreaterThan(depth, 0), LessThan(close_pos, StringLength(line))) {
                ch = StringCharAt(line, close_pos)
                IfCondition EqualTo(ch, 40) ThenBlock {
                    depth = Add(depth, 1)
                }
                IfCondition EqualTo(ch, 41) ThenBlock {
                    depth = Subtract(depth, 1)
                }
                close_pos = Add(close_pos, 1)
            }
            
            // Extract arguments (using corrected substring)
            args = StringSubstring(line, Add(paren_pos, 1), Subtract(close_pos, 1))
            
            // Convert Python built-ins to AIMacro equivalents
            IfCondition StringEquals(func_name, "print") ThenBlock {
                needs_compat = 1
                result = StringConcat("PrintMessage(", args)
                result = StringConcat(result, ")")
                g_return_value = result
                ReturnValue(0)
            }
            
            IfCondition StringEquals(func_name, "len") ThenBlock {
                needs_compat = 1
                result = StringConcat("ArrayLength(", args)
                result = StringConcat(result, ")")
                g_return_value = result
                ReturnValue(0)
            }
            
            IfCondition StringEquals(func_name, "range") ThenBlock {
                needs_compat = 1
                result = StringConcat("RangeArray(", args)
                result = StringConcat(result, ")")
                g_return_value = result
                ReturnValue(0)
            }
            
            IfCondition StringEquals(func_name, "str") ThenBlock {
                needs_compat = 1
                result = StringConcat("StringFromValue(", args)
                result = StringConcat(result, ")")
                g_return_value = result
                ReturnValue(0)
            }
            
            IfCondition StringEquals(func_name, "int") ThenBlock {
                needs_compat = 1
                result = StringConcat("StringToInt(", args)
                result = StringConcat(result, ")")
                g_return_value = result
                ReturnValue(0)
            }
            
            // Default: pass through unchanged
            result = StringConcat(func_name, "(")
            result = StringConcat(result, args)
            result = StringConcat(result, ")")
            g_return_value = result
            ReturnValue(0)
        }
        paren_pos = Add(paren_pos, 1)
    }
    
    g_return_value = ""
}

// Parse a statement
SubRoutine.ParseStatement {
    line = g_param1
    
    // Skip empty lines and comments
    IfCondition EqualTo(StringLength(line), 0) ThenBlock {
        ReturnValue(0)
    }
    
    first_ch = StringCharAt(line, 0)
    IfCondition EqualTo(first_ch, 35) ThenBlock {  // # comment
        ReturnValue(0)
    }
    
    // Check for Python-style def (convert to func)
    IfCondition GreaterEqual(StringLength(line), 3) ThenBlock {
        first_word = StringSubstring(line, 0, 3)
        IfCondition StringEquals(first_word, "def") ThenBlock {
            needs_compat = 1
            // Find function name
            name_start = 4
            WhileLoop And(LessThan(name_start, StringLength(line)), 
                         EqualTo(StringCharAt(line, name_start), 32)) {
                name_start = Add(name_start, 1)
            }
            
            paren_pos = name_start
            WhileLoop LessThan(paren_pos, StringLength(line)) {
                ch = StringCharAt(line, paren_pos)
                IfCondition EqualTo(ch, 40) ThenBlock {  // (
                    func_name = StringSubstring(line, name_start, paren_pos)
                    
                    g_param1 = StringConcat("Function.", func_name)
                    g_param1 = StringConcat(g_param1, " {")
                    RunTask(EmitIndented)
                    current_indent = Add(current_indent, 1)
                    
                    g_param1 = "Body: {"
                    RunTask(EmitIndented)
                    current_indent = Add(current_indent, 1)
                    
                    ReturnValue(0)
                }
                paren_pos = Add(paren_pos, 1)
            }
        }
    }
    
    // Check for return statement
    IfCondition GreaterEqual(StringLength(line), 6) ThenBlock {
        keyword = StringSubstring(line, 0, 6)
        IfCondition StringEquals(keyword, "return") ThenBlock {
            value_start = 6
            WhileLoop And(LessThan(value_start, StringLength(line)),
                         EqualTo(StringCharAt(line, value_start), 32)) {
                value_start = Add(value_start, 1)
            }
            
            value = StringSubstring(line, value_start, StringLength(line))
            
            // Check if value contains a function call
            g_param1 = value
            g_param2 = 0
            RunTask(ParseFunctionCall)
            parsed_value = g_return_value
            
            IfCondition GreaterThan(StringLength(parsed_value), 0) ThenBlock {
                g_param1 = StringConcat("ReturnValue(", parsed_value)
            } ElseBlock {
                g_param1 = StringConcat("ReturnValue(", value)
            }
            g_param1 = StringConcat(g_param1, ")")
            RunTask(EmitIndented)
            ReturnValue(0)
        }
    }
    
    // Check for AILANG escape block
    IfCondition GreaterEqual(StringLength(line), 6) ThenBlock {
        keyword = StringSubstring(line, 0, 6)
        IfCondition StringEquals(keyword, "ailang") ThenBlock {
            // Look for opening brace
            brace_pos = 6
            WhileLoop LessThan(brace_pos, StringLength(line)) {
                ch = StringCharAt(line, brace_pos)
                IfCondition EqualTo(ch, 123) ThenBlock {  // {
                    g_param1 = "// BEGIN AILANG ESCAPE"
                    RunTask(EmitIndented)
                    
                    // Read until closing brace (simplified - assumes single line for now)
                    // In full implementation, would track brace depth across lines
                    escape_start = Add(brace_pos, 1)
                    escape_end = StringLength(line)
                    
                    // Find closing brace
                    close_pos = escape_start
                    WhileLoop LessThan(close_pos, StringLength(line)) {
                        ch = StringCharAt(line, close_pos)
                        IfCondition EqualTo(ch, 125) ThenBlock {  // }
                            escape_end = close_pos
                        }
                        close_pos = Add(close_pos, 1)
                    }
                    
                    ailang_code = StringSubstring(line, escape_start, escape_end)
                    g_param1 = ailang_code
                    RunTask(EmitIndented)
                    
                    g_param1 = "// END AILANG ESCAPE"
                    RunTask(EmitIndented)
                    ReturnValue(0)
                }
                brace_pos = Add(brace_pos, 1)
            }
        }
    }
    
    // Check for ASM escape block (optional)
    IfCondition GreaterEqual(StringLength(line), 3) ThenBlock {
        keyword = StringSubstring(line, 0, 3)
        IfCondition StringEquals(keyword, "asm") ThenBlock {
            // Similar to AILANG escape but marks as inline assembly
            brace_pos = 3
            WhileLoop LessThan(brace_pos, StringLength(line)) {
                ch = StringCharAt(line, brace_pos)
                IfCondition EqualTo(ch, 123) ThenBlock {  // {
                    g_param1 = "// BEGIN ASM ESCAPE"
                    RunTask(EmitIndented)
                    g_param1 = "InlineAssembly {"
                    RunTask(EmitIndented)
                    current_indent = Add(current_indent, 1)
                    
                    // Extract assembly code (simplified)
                    escape_start = Add(brace_pos, 1)
                    escape_end = StringLength(line)
                    close_pos = escape_start
                    WhileLoop LessThan(close_pos, StringLength(line)) {
                        ch = StringCharAt(line, close_pos)
                        IfCondition EqualTo(ch, 125) ThenBlock {  // }
                            escape_end = close_pos
                        }
                        close_pos = Add(close_pos, 1)
                    }
                    
                    asm_code = StringSubstring(line, escape_start, escape_end)
                    g_param1 = asm_code
                    RunTask(EmitIndented)
                    
                    current_indent = Subtract(current_indent, 1)
                    g_param1 = "}"
                    RunTask(EmitIndented)
                    g_param1 = "// END ASM ESCAPE"
                    RunTask(EmitIndented)
                    ReturnValue(0)
                }
                brace_pos = Add(brace_pos, 1)
            }
        }
    }
    
        IfCondition GreaterThan(current_indent, 0) ThenBlock {
            current_indent = Subtract(current_indent, 1)
            g_param1 = "}"
            RunTask(EmitIndented)
        }
        IfCondition GreaterThan(current_indent, 0) ThenBlock {
            current_indent = Subtract(current_indent, 1)
            g_param1 = "}"
            RunTask(EmitIndented)
        }
        ReturnValue(0)
    }
    
    // Check for function calls (print, len, etc)
    g_param1 = line
    g_param2 = 0
    RunTask(ParseFunctionCall)
    result = g_return_value
    
    IfCondition GreaterThan(StringLength(result), 0) ThenBlock {
        g_param1 = result
        RunTask(EmitIndented)
        ReturnValue(0)
    }
    
    // Check for assignment
    i = 0
    WhileLoop LessThan(i, StringLength(line)) {
        ch = StringCharAt(line, i)
        IfCondition EqualTo(ch, 61) ThenBlock {  // =
            var_name = StringSubstring(line, 0, i)
            value = StringSubstring(line, Add(i, 1), StringLength(line))
            
            // Trim spaces from var_name and value
            // (simplified for now)
            
            g_param1 = StringConcat(var_name, " = ")
            g_param1 = StringConcat(g_param1, value)
            RunTask(EmitIndented)
            ReturnValue(0)
        }
        i = Add(i, 1)
    }
    
    // Default: pass through
    g_param1 = line
    RunTask(EmitIndented)
}

// Main transpiler
SubRoutine.TranspileAIMacro {
    source = g_param1
    
    g_param1 = source
    RunTask(InitParser)
    
    g_param1 = "// Generated from AIMacro"
    RunTask(EmitIndented)
    
    // Check if python_compat needed
    IfCondition EqualTo(needs_compat, 1) ThenBlock {
        g_param1 = "// Note: Uses Python compatibility functions"
        RunTask(EmitIndented)
        g_param1 = "// LibraryImport.python_compat"
        RunTask(EmitIndented)
    }
    
    g_param1 = ""
    RunTask(EmitIndented)
    
    WhileLoop LessThan(parser_pos, parser_length) {
        RunTask(GetLine)
        line = g_return_value
        
        // Trim leading spaces
        start = 0
        len = StringLength(line)
        WhileLoop And(LessThan(start, len), 
                      Or(EqualTo(StringCharAt(line, start), 32),
                         EqualTo(StringCharAt(line, start), 9))) {
            start = Add(start, 1)
        }
        
        IfCondition LessThan(start, len) ThenBlock {
            trimmed = StringSubstring(line, start, len)
            g_param1 = trimmed
            RunTask(ParseStatement)
        }
    }
    
    // Close any remaining blocks
    WhileLoop GreaterThan(current_indent, 0) {
        current_indent = Subtract(current_indent, 1)
        g_param1 = "}"
        RunTask(EmitIndented)
    }
    
    g_return_value = output
}

// Test program
LoopMain.TestAIMacro {
    test_code = "# Python-compatible AIMacro with escape hatches
def calculate(x, y):
    result = x + y
    print(result)
    return result
end

def optimize():
    # Use AILANG escape for performance
    ailang { WhileLoop LessThan(i, 100) { ArraySet(data, i, 0) } }
    # Use ASM escape for syscalls
    asm { MOV RAX, 1 }
    return 0
pass

def main():
    total = 0
    values = range(5)
    length = len(values)
    print(length)
    return total
pass"
    
    PrintMessage("AIMacro Parser v3.0 - Python Compatible")
    PrintMessage("========================================")
    PrintMessage("Input code:")
    PrintMessage(test_code)
    PrintMessage("")
    
    g_param1 = test_code
    RunTask(TranspileAIMacro)
    result = g_return_value
    
    PrintMessage("Output AILANG code:")
    PrintMessage(result)
    PrintMessage("")
    PrintMessage("Python compatibility library stub:")
    PrintMessage("// python_compat.ailang")
    PrintMessage("// Alias print = PrintMessage")
    PrintMessage("// Alias len = ArrayLength") 
    PrintMessage("// Alias range = RangeArray")
    PrintMessage("// Alias str = StringFromValue")
    PrintMessage("// Alias int = StringToInt")
}

// Version History:
// v3.1   - Added AILANG and ASM escape blocks
//        - ailang { } for performance-critical AILANG code
//        - asm { } for inline assembly when needed
//        - Maintains high-level convenience with low-level control
// v3.0   - Function-style syntax for Python compatibility
//        - Handles print(), len(), range(), str(), int()
//        - Supports def/pass for Python developers
//        - Stub for python_compat library
// v2.x   - @ macro style (deprecated for function consistency)
// v1.x   - Initial attempts
